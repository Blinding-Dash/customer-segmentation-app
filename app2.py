import os
import pandas as pd
import numpy as np
import streamlit as st
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from kneed import KneeLocator
import google.generativeai as genai

# --- Page Configuration ---
st.set_page_config(layout="wide", page_title="AI Customer Segmentation")

# --- Persona Generation Function (No Caching) ---
def generate_persona_with_gemini(cluster_summary_str, retries=3):
    """Generates a persona using the Gemini API."""
    api_key = os.getenv("GOOGLE_API_KEY")
    if not api_key:
        return "API Key not configured. Persona generation is disabled."

    genai.configure(api_key=api_key)
    model = genai.GenerativeModel('gemini-1.5-flash')
    
    prompt = f"""
You are an expert marketing analyst.
Based on the following cluster data, create a detailed persona including:
- Demographic traits (age, income, gender)
- Behavioral traits (recency, frequency, spending, loyalty, channel preferences)
- Psychographic traits (eco concern, innovativeness, lifestyle, brand loyalty, values)
- Goals and motivations
- Pain points and challenges
- Actionable marketing strategies

Here is the cluster data:
{cluster_summary_str}
"""

    for attempt in range(retries):
        try:
            response = model.generate_content(prompt)
            return response.text.strip()
        except Exception as e:
            if attempt < retries - 1:
                st.write(f"API call failed, retrying... ({attempt+1}/{retries})")
            else:
                st.error(f"Error generating persona after {retries} attempts: {e}")
                return f"Could not generate persona. Error: {e}"
    return "Failed to generate persona after several retries."


# --- Main App ---
st.title("ðŸš€ AI-Powered Customer Segmentation & Persona Builder")
st.markdown("Upload your customer data to segment users and automatically generate marketing personas with AI.")

# --- Sidebar ---
with st.sidebar:
    st.header("âš™ï¸ App Settings")
    if os.getenv("GOOGLE_API_KEY"):
        st.success("âœ… Gemini API Key Loaded!")
    else:
        st.error("âŒ Gemini API Key Not Found!")
        st.warning("Set the GOOGLE_API_KEY environment variable to enable AI features.")
    
    st.header("ðŸ“Š Feature Selection")
    st.info("Select the features you want to include for clustering your customers.")

# --- Help / Glossary Section ---
with st.sidebar.expander("ðŸ“– Help & Glossary"):
    st.markdown("""
    ### Glossary of Terms

    **Segmentation**  
    The process of dividing customers into groups with similar characteristics.

    **Clustering**  
    A machine learning method that groups similar data points together.  
    Here, we use **K-Means Clustering**.

    **K-Means Clustering**  
    An algorithm that divides customers into *K* clusters based on similarity.  
    Each cluster is represented by its center (mean).

    **Recency (R)**  
    Number of days since the customerâ€™s last purchase.  
    - Lower = more recent â†’ more engaged.

    **Frequency (F)**  
    How many times the customer has purchased in a period (e.g., per year).  
    - Higher = more loyal.

    **Monetary (M)**  
    Total amount spent by the customer.  
    - Higher = more valuable.

    **RFM Segmentation**  
    A marketing method that uses Recency, Frequency, and Monetary value to classify customers.

    **One-Hot Encoding**  
    A way to convert categories (like Gender: Male/Female/Other) into numeric form for clustering.

    **StandardScaler**  
    A preprocessing step that normalizes features so they have equal weight in clustering.

    **Silhouette Score**  
    A measure of how well clusters are separated.  
    - Close to +1 = distinct clusters  
    - Close to 0 = overlapping clusters

    **Persona**  
    A semi-fictional representation of a customer segment, including demographics, behaviors, psychographics, and strategies.

    ---
    ### Calculations Done in Background
    - All numeric features are standardized (z-scores).  
    - Categorical features are converted to numeric using one-hot encoding.  
    - K-Means clustering assigns each customer to the nearest cluster center.  
    - Cluster summaries are calculated using group averages.  
    - Personas are generated by Gemini AI based on cluster summaries.
    """)


# --- Data Loading ---
uploaded_file = st.file_uploader("Upload your customer CSV file", type="csv")
if uploaded_file:
    df = pd.read_csv(uploaded_file)
else:
    st.info("Using sample dataset...")
    df = pd.DataFrame({
        "CustomerID": range(1, 201),
        "Age": np.random.randint(18, 70, 200),
        "Annual Income (k$)": np.random.randint(15, 137, 200),
        "Spending Score (1-100)": np.random.randint(1, 99, 200),
        "Gender": np.random.choice(["Male", "Female", "Other"], 200, p=[0.45, 0.45, 0.10])
    })

st.write("### Glimpse of the Data")
st.dataframe(df.head())

# --- Feature Engineering and Selection ---
numeric_cols = df.select_dtypes(include=np.number).columns.tolist()
if 'CustomerID' in numeric_cols:
    numeric_cols.remove('CustomerID')

selected_features = st.sidebar.multiselect(
    "Select features for clustering:",
    options=numeric_cols,
    default=numeric_cols
)

features = pd.DataFrame() # Initialize features DataFrame
if selected_features:
    numeric_data = df[selected_features]
    categorical_features = df.select_dtypes(include=['object', 'category'])
    if not categorical_features.empty:
        encoded_cats = pd.get_dummies(categorical_features, drop_first=False)
        features = pd.concat([numeric_data, encoded_cats], axis=1)
    else:
        features = numeric_data

    scaler = StandardScaler()
    X = scaler.fit_transform(features)

    # --- Automating K Selection ---
    st.header("Finding the Optimal Number of Clusters (K)")
    
    inertia = []
    k_range = range(1, 11)
    for i in k_range:
        kmeans_elbow = KMeans(n_clusters=i, random_state=42, n_init='auto')
        kmeans_elbow.fit(X)
        inertia.append(kmeans_elbow.inertia_)
    
    kl = KneeLocator(k_range, inertia, curve='convex', direction='decreasing')
    optimal_k = kl.elbow if kl.elbow else 3

    fig_elbow, ax_elbow = plt.subplots()
    ax_elbow.plot(k_range, inertia, marker='o', linestyle='--')
    ax_elbow.vlines(optimal_k, ax_elbow.get_ylim()[0], ax_elbow.get_ylim()[1], linestyles='dotted', colors='red')
    ax_elbow.set_xlabel('Number of Clusters (K)')
    ax_elbow.set_ylabel('Inertia')
    ax_elbow.set_title('Elbow Method For Optimal K')
    st.pyplot(fig_elbow)
    
    st.success(f"**Optimal K Found: {optimal_k}**")
    
    explanation_text = """
    Based on the Elbow Method, we've automatically selected **{k} clusters**. 
    This is the point on the chart (marked by the red dotted line) where the model's performance gain starts to slow down significantly, indicating a good balance between the number of clusters and model accuracy.
    """.format(k=optimal_k)
    st.markdown(explanation_text)

    # --- Main Panel: Clustering Results & Personas ---
    kmeans = KMeans(n_clusters=optimal_k, random_state=42, n_init=10)
    labels = kmeans.fit_predict(X)
    df['Cluster'] = labels

    st.write("### Clustered Data")
    st.dataframe(df.head())

    # Create a single DataFrame for plotting that includes encoded columns
    if 'encoded_cats' in locals() and not encoded_cats.empty:
        df_plot = pd.concat([df, encoded_cats], axis=1)
    else:
        df_plot = df

    summary_df = features.copy()
    summary_df['Cluster'] = labels
    cluster_summary = summary_df.groupby('Cluster').mean()

    st.header("ðŸ“„ Cluster Analysis & AI-Generated Personas")
    st.write("#### Cluster Summary (Averages)")
    st.dataframe(cluster_summary)

    for cluster_id in sorted(df['Cluster'].unique()):
        st.markdown("---")
        st.subheader(f"ðŸ¤– Persona for Cluster {cluster_id}")
        
        summary_data = cluster_summary.loc[cluster_id].to_dict()
        summary_str = ", ".join([f"{key}: {value:.2f}" for key, value in summary_data.items()])

        with st.spinner(f"âœ¨ Generating persona for Cluster {cluster_id} with Gemini..."):
            persona_text = generate_persona_with_gemini(summary_str)
            st.markdown(persona_text)

    # --- Visualization Section ---
    st.header("ðŸ“ˆ Cluster Visualization")
    tab1, tab2 = st.tabs(["2D Plot", "3D Plot"])

    with tab1:
        st.subheader("2D Scatter Plot")
        # --- FIX: Add a check to ensure at least 2 features are selected ---
        if len(features.columns) >= 2:
            col1, col2 = st.columns(2)
            with col1:
                x_axis = st.selectbox("Select X-axis", features.columns, index=0)
            with col2:
                y_axis = st.selectbox("Select Y-axis", features.columns, index=1)
            
            fig_2d, ax_2d = plt.subplots(figsize=(10, 7))
            sns.scatterplot(data=df_plot, x=x_axis, y=y_axis, hue="Cluster", palette="viridis", s=100, alpha=0.8, ax=ax_2d)
            ax_2d.set_title(f'Clusters by {x_axis} vs {y_axis}')
            st.pyplot(fig_2d)
        else:
            st.warning("Please select at least two features from the sidebar to create a 2D plot.")

    with tab2:
        st.subheader("3D Interactive Plot")
        if len(features.columns) >= 3:
            col1, col2, col3 = st.columns(3)
            with col1:
                x_3d = st.selectbox("Select X-axis", features.columns, index=0, key="3d_x")
            with col2:
                y_3d = st.selectbox("Select Y-axis", features.columns, index=1, key="3d_y")
            with col3:
                z_3d = st.selectbox("Select Z-axis", features.columns, index=2, key="3d_z")

            fig_3d = px.scatter_3d(
                df_plot, x=x_3d, y=y_3d, z=z_3d, color='Cluster',
                title='3D Scatter Plot of Clusters'
            )
            fig_3d.update_traces(marker=dict(size=5))
            st.plotly_chart(fig_3d, use_container_width=True)
        else:
            st.warning("Please select at least three features to create a 3D plot.")
else:
    st.warning("Please select at least one feature from the sidebar to begin clustering.")